/* 
    _________________________________________
    | IMPORTANTE!!!                          |
    | = é para igual                         |
    | <> ou != é para diferente              |
    | LIKE com % é coringa                   |
    | Para textos use aspas simples 'texto'  | 
    | Para números NÃO use aspas             |
	|________________________________________|
----------------------------------------------------------------------------
	WHERE
	coluna1 BETWEEN 100 AND 500 
	--BETWEEN é inclusivo (100 e 500 entram)
----------------------------------------------------------------------------
*/

************************************ AMBIENTAÇÃO ************************************

-- Qual bd estou?              
SELECT DB_NAME();

-- Listar todos os bd
SELECT name FROM sys.databases ORDER BY name;

-- Usar bd
USE nome_do_banco;

-- Executar bd
EXEC sp_helpdb 'nome_do_banco';

************************************ FIM AMBIENTAÇÃO ************************************

************************************ CONSULTAS ************************************

-- Consulta completa do bd
SELECT *
FROM nome_da_tabela;

-- Consulta Top 10 
SELECT TOP 10 *
FROM nome_da_tabela

-- Consulta Top 10 de colunas específicas
SELECT TOP 10 
    coluna1, 
    coluna2
FROM nome_da_tabela;

-- Consulta Distinta (remove duplicatas dos resultados)
SELECT DISTINCT 
    coluna1, 
    coluna2
FROM nome_da_tabela;

************************************ FIM CONSULTAS ************************************

************************************ PESQUISAS WHERE ************************************

-- pesquisas (LIKE, NOT LIKE, =, <>, MAIOR/MENOR/IGUAL, OR, AND, BETWEEN, IN, NOT IN, NULL/NOTNULL, DATAS/ENTRE DATAS, )
SELECT 
    coluna1, 
    coluna2,
    coluna3
FROM nome_do_banco
WHERE 
------------ LIKE -----------------
	coluna1 LIKE '%dado_pesquis%';
    coluna1 LIKE 'inicio%';     -- Começa com
    coluna1 LIKE '%fim';        -- Termina com

------------ NOT LIKE -----------------
	coluna1 NOT LIKE '%dado_pesquis%';

------------ IGUAL -----------------
	coluna1 = 'dado_pesquisado_01';

------------ DIFERENTE -----------------
	coluna1 <> 'dado_pesquisado_01';

------------ MAIOR/MENOR/IGUAL -----------------
    coluna1 > 100;
    coluna1 >= 100;
    coluna1 < 100;
    coluna1 <= 100;

------------ OR -----------------
    coluna1 = 'dado_01' 
	OR coluna2 = 'dado_02'
	OR coluna3 = 'dado_03';

------------ E -----------------
    coluna1 = 'dado_01' 
	AND coluna2 = 'dado_02'
	AND coluna3 = 'dado_03';

------------ BETWEEN -----------------
    coluna1 BETWEEN 100 AND 500;

------------ IN -----------------
    coluna1 IN ('dado_01',
	'dado_02', 
	'dado_03');

------------ NOT IN -----------------
    coluna1 NOT IN ('dado_01',
	'dado_02', 
	'dado_03');

------------ NULL / NOT NULL -----------------
    coluna1 IS NULL;
    coluna1 IS NOT NULL;

------------  DATAS/ENTRE DATAS -----------------
    coluna1 BETWEEN '2024-01-01' AND '2024-12-31';
    YEAR(coluna1) = 2024;
    MONTH(coluna1) = 01;

************************************ FIM PESQUISAS WHERE ************************************

************************************ ORDENAR ************************************
-- ordenações (PADRÃO ASC/DESC, MÚLTIPLAS COLUNAS, COLUNAS CONSIDERADAS NÚMEROS, STRINGS TERÃO POSIÇÕES ESPECÍFICAS, TAMANHO DO TEXTO, STRINGS TERÃO POSIÇÕES ESPECÍFICA, TRECHOS TERÃO POSIÇÕES ESPECÍFICAS, NULLS NO FINAL, ORDENAR ALEATÓRIO)
SELECT
    coluna1, 
    coluna2,
    coluna3
FROM nome_do_banco
ORDER BY 
------------ PADRÃO ASC/DESC -----------------
coluna1;  -- DESC para decrescente, ASC é o padrão

------------ MÚLTIPLAS COLUNAS -----------------
    coluna1,
    coluna2;

------------ COLUNAS CONSIDERADAS NÚMEROS -----------------
	1, 3 -- 1 = primeira coluna do SELECT e 3 a terceira

------------ TAMANHO DO TEXTO -----------------
    LEN(coluna1) DESC;  -- Ordena pelo tamanho do texto

------------ STRINGS TERÃO POSIÇÕES ESPECÍFICAS -----------------
    CASE coluna1
        WHEN 'dado01' THEN 1 -- qualquer que seja 'dado01' será 1º na ordenação
        WHEN 'PENDENTE' THEN 2  -- qualquer que seja 'dado02' será 2º na ordenação
        WHEN 'INATIVO' THEN 3 -- qualquer que seja 'dado03' será 3º na ordenação
        ELSE 4 --demais 'dados' serão 4º na ordenação
    END;

------------ TRECHOS TERÃO POSIÇÕES ESPECÍFICAS -----------------
    CASE 
        WHEN coluna1 LIKE '%URGENTE%' THEN 1
        WHEN coluna1 LIKE '%IMPORTANTE%' THEN 2  
        ELSE 3
    END,

------------ NULLS NO FINAL -----------------
    coluna1 ASC NULLS LAST;   -- Nulos no final (SQL Server 2022+)

------------ ORDENAR ALEATÓRIO -----------------
ORDER BY NEWID();  -- Ordem aleatória (SQL Server)

************************************ FIM DE ORDENAR ************************************

************************************ AGRUPAR ************************************
___________________________________________________________________________________________________
| IMPORTANTE!!!                                                                                    |
| GROUP BY tem que ter função de agregação em SELECT (COUNT, SUM, AVG, MAX, MIN)                   |
| Toda coluna no SELECT que NÃO estiver dentro de COUNT/SUM/AVG/MAX/MIN precisa estar no GROUP BY! |
|__________________________________________________________________________________________________|
 -- Agrupamentos (Contagem, MÚLTIPLAS, HAVING)
SELECT
    coluna1,
    COUNT(*) AS total,      -- Obrigatório ter ao menos uma das agregação!
    SUM(coluna2) AS soma,
    AVG(coluna3) AS media,
    MAX(data) AS ultimo,
    MIN(data) AS primeiro
FROM nome_do_banco
GROUP BY coluna1; 

-- Contagem de linhas dados da coluna
SELECT 
    coluna1,
    COUNT(*) AS qtd
FROM nome_do_banco
GROUP BY coluna1;

-- 2. MÚLTIPLAS AGREGAÇÕES
SELECT 
    coluna1,
    coluna2,
    COUNT(*) AS total,
    AVG(nota_media) AS media,
    MAX(data_fundacao) AS maximo
FROM nome_do_banco
GROUP BY coluna1, coluna2;

-- 3. FILTRANDO GRUPOS (HAVING)
SELECT 
    categoria,
    COUNT(*) AS total,
    AVG(preco) AS preco
FROM produtos
GROUP BY categoria
HAVING COUNT(*) > 10  -- Só categorias com +10 produtos
    AND AVG(preco) > 50;  -- E preço médio > 50

************************************ FIM AGRUPAR ************************************

************************************ TEMPORÁRIAS ************************************

------------ Criar Temporária ------------
DROP TABLE IF EXISTS #temp_01;
SELECT 
    coluna1, 
    coluna2
INTO #temp_01 
FROM nome_da_tabela;

------------ CRIAR ESTRUTURA SEM DADOS ------------
DROP TABLE IF EXISTS #temp_vazia;
SELECT TOP 0 * 
INTO #temp_vazia 
FROM nome_da_tabela;  -- Cria cópia da estrutura, sem dados

************************************ FIM TEMPORÁRIAS ************************************

************************************ EDITAR TEMPORÁRIAS ************************************
DROP TABLE IF EXISTS #temp_01;
SELECT
------------ RETIRAR NULL ------------
ISNULL(coluna1,'') AS novo_nome1,
ISNULL(coluna2, 0) AS com_zero, 

------------ INVERSO DO IS NULL ------------
NULLIF(coluna, 0) AS transforma_zero_em_null 

------------ RENOMEAR COLUNAS ------------ 
    coluna1 AS novo_nome1,
    coluna2 AS novo_nome2

------------ RENOMEAR COLUNA EXISTENTE ------------
EXEC tempdb..sp_rename '#temp_01.coluna1', 'novo_nome', 'COLUMN'; --funciona fora da estrutura do SELECT

--------- ACRESCENTAR COLUNA VAZIA COM CABEÇALHO ---------
ALTER TABLE #temp_01 
ADD idade INT;

--------- EXCLUIR COLUNAS ---------
ALTER TABLE #temp_01 
DROP COLUMN coluna1, coluna2;

--------- SUBSTITUIR VALORES NA PRIMEIRA LINHA DAS COLUNAS ---------
INSERT INTO #temp_01 (coluna1, coluna2) 
VALUES ('valor1', 'valor2'); 

--------- SUBSTITUIR VALORES NAS PRIMEIRAS LINHAS DAS COLUNAS ---------
INSERT INTO #temp_01 (coluna1, coluna2) 
VALUES 
    ('a', 1),
    ('b', 2),
    ('c', 3);

--------- SUBSTITUIR COLUNAS DE UMA outra_tabela EM CIMA DE OUTRA #temp_01 ---------
INSERT INTO #temp_01 (coluna1, coluna2)
SELECT campo1, campo2 
FROM outra_tabela -- SE campo1, campo2 FOR MENOR QUE coluna1, coluna2 AS ÚLTIMAS LINHAS DAS ANTIGAS COLUNAS CONTINUARAM ABAIXO, SE MAIOR OU IGUAL OK

--------- SUBSTITUIÇÃO DE DADOS ESPECÍFICOS DA COLUNA ---------
-- Atualização simples
UPDATE #temp_01 
SET coluna1 = 'novo_valor'
WHERE coluna2 = 'dado02'; -- todos os dados da coluna1 que estão paralelos ao dado02 da coluna2 serão modificados para novo_valor

--------- SUBSTITUIÇÃO DE DADOS ESPECÍFICOS DA COLUNA ---------
UPDATE t
SET t.coluna1 = o.valor_corrigido
FROM #temp_01 t
INNER JOIN tabela_origem o ON t.id = o.id; -- dados da coluna id em ambas que forem iguais farão substituições em t.coluna1 com novos valores vindos da coluna o.valor_corrigido.

-- Atualização em massa
UPDATE #temp_01 
SET 
    status = 'INATIVO',
    data_alteracao = GETDATE(),
    usuario = 'SISTEMA'
WHERE data_cadastro < '2020-01-01';

--------- 7. EXCLUIR LINHAS ---------
DELETE FROM #temp_01 
WHERE coluna1 IS NULL;

-- TRUNCATE (limpa TUDO, mais rápido)
TRUNCATE TABLE #temp_01;

--------- 8. JUNTAR DUAS TEMPORÁRIAS ---------
-- UNION (empilha)
SELECT * INTO #temp_uniao
FROM (
    SELECT col1, col2 FROM #temp_a
    UNION ALL  -- ALL mantém duplicatas, UNION remove
    SELECT col1, col2 FROM #temp_b
) AS uniao;

-- JOIN (horizontal)
SELECT 
    a.*,
    b.coluna_extra,
    c.outra_coluna
INTO #temp_join
FROM #temp_a a
LEFT JOIN #temp_b b ON a.id = b.id
INNER JOIN #temp_c c ON a.id = c.id;

--------- 9. MERGE (UPSERT = Insert + Update) ---------
MERGE INTO #temp_destino AS destino
USING #temp_origem AS origem
    ON destino.id = origem.id
WHEN MATCHED THEN
    UPDATE SET 
        destino.nome = origem.nome,
        destino.valor = origem.valor
WHEN NOT MATCHED THEN
    INSERT (id, nome, valor)
    VALUES (origem.id, origem.nome, origem.valor);

--------- 10. ORDENAR DADOS NA TEMP ---------
-- Temp não tem ordem, mas você pode criar uma coluna de ordem
SELECT 
    *,
    ROW_NUMBER() OVER (ORDER BY data DESC) AS ordem_prioridade
INTO #temp_ordenada
FROM #temp_01;

--------- 11. ADICIONAR CONSTRAINT (PK, FK, CHECK) ---------
ALTER TABLE #temp_01
ADD CONSTRAINT pk_temp PRIMARY KEY (id);  -- Chave primária

ALTER TABLE #temp_01
ADD CONSTRAINT ck_idade CHECK (idade >= 0);  -- Regra de validação

--------- 12. CRIAR CÓPIA EXATA ---------
-- Estrutura + dados
SELECT * INTO #temp_copia FROM #temp_original;

-- Só estrutura (sem dados)
SELECT TOP 0 * INTO #temp_vazia FROM #temp_original;

--------- 13. VER ESTRUTURA DA TEMP ---------
-- No SSMS: sp_help
EXEC tempdb..sp_help '#temp_01';

-- Colunas e tipos
SELECT 
    c.name AS coluna,
    t.name AS tipo,
    c.max_length AS tamanho,
    c.is_nullable AS permite_null
FROM tempdb.sys.columns c
JOIN tempdb.sys.types t ON c.user_type_id = t.user_type_id
WHERE object_id = OBJECT_ID('tempdb..#temp_01');

--------- 14. LIMPAR TEMPORÁRIAS ---------
-- Remove uma específica
DROP TABLE IF EXISTS #temp_01;

-- Remove TODAS da sua sessão (cuidado!)
DECLARE @sql VARCHAR(MAX) = '';
SELECT @sql = @sql + 'DROP TABLE ' + name + ';'
FROM tempdb.sys.tables 
WHERE name LIKE '#%' AND name NOT LIKE '##%'
AND object_id IN (
    SELECT object_id FROM tempdb.sys.objects
    WHERE session_id = @@SPID
);
EXEC(@sql);


************************************ FIM EDITAR TEMPORÁRIAS ************************************

*************************** INÍCIO COMANDOS ELABORADOS *********************************
-- Criação de e-mails
SELECT TOP 10 *, -- Seleciona as 10 primeiras linhas da consulta, e todas as colunas (*)            
              CASE  -- Inicia um CASE para lógica condicional                  
                  WHEN CATESC='VINCULADA' THEN -- Condição: quando a coluna CATESC for igual a 'VINCULADA' então
                      CONCAT('e', FORMAT(ESCVINC, '000000'), 'a@educacao.sp.gov.br') -- Se acima for verdadeiro: cria um email concatenando String 'e' com o número de ESCVINC em 6 dígitos (preenche com zeros à esquerda se ESCVINC < 6 dígitos) concatena com String 'a@educacao.sp.gov.br'                
                  ELSE -- Se falso:
                      CONCAT('e', FORMAT(CODESC, '000000'), 'a@educacao.sp.gov.br')   -- cria um email concatenando String 'e' com o número de CODESC em 6 dígitos (preenche com zeros à esquerda se CODESC < 6 dígitos) concatena com String 'a@educacao.sp.gov.br'      
              END               
              AS EMAIL -- Nome da nova coluna calculada como 'EMAIL'
FROM dbo.nome_do_esquema -- Especifica a tabela de origem com esquema dbo

-- extrair zeros de RG
SELECT 
    -- Exemplo: pegar apenas os primeiros 12 caracteres do RG
    LEFT(NR_RG, 12) AS RG_TRUNCADO,
    -- Exemplo prático com nomes: primeiras 3 letras da URE
    LEFT(NOME_URE, 3) AS SIGLA_URE,
    -- Exemplo: código reduzido (primeiros 3 dígitos)
    LEFT(CODESC, 3) AS PREFIXO_CODIGO,
    -- Combine com outras funções
    CONCAT(
        LEFT(NOME_URE, 3),  -- Primeiras 3 letras da URE
        '-',
        LEFT(NOMESC, 10)    -- Primeiras 10 letras da escola
    ) AS CODIGO_REDUZIDO
FROM #ESCOLAS A;

*************************** FIM COMANDOS ELABORADOS *********************************
