/* 
    _________________________________________
    | IMPORTANTE!!!                          |
    | = é para igual                         |
    | <> ou != é para diferente              |
    | LIKE com % é coringa                   |
    | Para textos use aspas simples 'texto'  | 
    | Para números NÃO use aspas             |
	|________________________________________|
----------------------------------------------------------------------------
	WHERE
	coluna1 BETWEEN 100 AND 500 
	--BETWEEN é inclusivo (100 e 500 entram)
----------------------------------------------------------------------------
*/
*************************** COMANDOS EATI *********************************
-- Criação de e-mails
SELECT TOP 10 *, -- Seleciona as 10 primeiras linhas da consulta, e todas as colunas (*)            
              CASE  -- Inicia um CASE para lógica condicional                  
                  WHEN CATESC='VINCULADA' THEN -- Condição: quando a coluna CATESC for igual a 'VINCULADA' então
                      CONCAT('e', FORMAT(ESCVINC, '000000'), 'a@educacao.sp.gov.br') -- Se acima for verdadeiro: cria um email concatenando String 'e' com o número de ESCVINC em 6 dígitos (preenche com zeros à esquerda se ESCVINC < 6 dígitos) concatena com String 'a@educacao.sp.gov.br'                
                  ELSE -- Se falso:
                      CONCAT('e', FORMAT(CODESC, '000000'), 'a@educacao.sp.gov.br')   -- cria um email concatenando String 'e' com o número de CODESC em 6 dígitos (preenche com zeros à esquerda se CODESC < 6 dígitos) concatena com String 'a@educacao.sp.gov.br'      
              END               
              AS EMAIL -- Nome da nova coluna calculada como 'EMAIL'
FROM dbo.nome_do_esquema -- Especifica a tabela de origem com esquema dbo

-- extrair zeros de RG
SELECT 
    -- Exemplo: pegar apenas os primeiros 12 caracteres do RG
    LEFT(NR_RG, 12) AS RG_TRUNCADO,
    -- Exemplo prático com nomes: primeiras 3 letras da URE
    LEFT(NOME_URE, 3) AS SIGLA_URE,
    -- Exemplo: código reduzido (primeiros 3 dígitos)
    LEFT(CODESC, 3) AS PREFIXO_CODIGO,
    -- Combine com outras funções
    CONCAT(
        LEFT(NOME_URE, 3),  -- Primeiras 3 letras da URE
        '-',
        LEFT(NOMESC, 10)    -- Primeiras 10 letras da escola
    ) AS CODIGO_REDUZIDO
FROM #ESCOLAS A;

-- campo de e-mail faltando
SELECT DISTINCT
	COLUNA1
	COALESCE(NULLIF(EMAIL_INST2, ''), EMAIL_INST1) AS EMAILI_DIRETOR,  -- NULLIF converte string vazia para NULL, só assim COALESCE funciona para acrescentar e-mail2 quando email1 for vazio 
	COLUNA3
INTO #DIR 
FROM CTG1225

*************************** FIM COMANDOS EATI *********************************

************************************ AMBIENTAÇÃO ************************************

-- Qual bd estou?              
SELECT DB_NAME();

-- Listar todos os bd
SELECT name FROM sys.databases ORDER BY name;

-- Usar bd
USE nome_do_banco;

-- Executar bd
EXEC sp_helpdb 'nome_do_banco';

************************************ FIM AMBIENTAÇÃO ************************************

************************************ CONSULTAS ************************************

-- Consulta completa do bd
SELECT *
FROM nome_da_tabela;

-- Consulta Top 10 
SELECT TOP 10 *
FROM nome_da_tabela

-- Consulta Top 10 de colunas específicas
SELECT TOP 10 
    coluna1, 
    coluna2
FROM nome_da_tabela;

-- Consulta Distinta (remove duplicatas dos resultados)
SELECT DISTINCT 
    coluna1, 
    coluna2
FROM nome_da_tabela;

************************************ FIM CONSULTAS ************************************

************************************ PESQUISAS WHERE ************************************

-- pesquisas (LIKE, NOT LIKE, =, <>, MAIOR/MENOR/IGUAL, OR, AND, BETWEEN, IN, NOT IN, NULL/NOTNULL, DATAS/ENTRE DATAS, )
SELECT 
    coluna1, 
    coluna2,
    coluna3
FROM nome_do_banco
WHERE 
------------ LIKE -----------------
	coluna1 LIKE '%dado_pesquis%';
    coluna1 LIKE 'inicio%';     -- Começa com
    coluna1 LIKE '%fim';        -- Termina com

------------ NOT LIKE -----------------
	coluna1 NOT LIKE '%dado_pesquis%';

------------ IGUAL -----------------
	coluna1 = 'dado_pesquisado_01';

------------ DIFERENTE -----------------
	coluna1 <> 'dado_pesquisado_01';

------------ MAIOR/MENOR/IGUAL -----------------
    coluna1 > 100;
    coluna1 >= 100;
    coluna1 < 100;
    coluna1 <= 100;

------------ OR -----------------
    coluna1 = 'dado_01' 
	OR coluna2 = 'dado_02'
	OR coluna3 = 'dado_03';

------------ E -----------------
    coluna1 = 'dado_01' 
	AND coluna2 = 'dado_02'
	AND coluna3 = 'dado_03';

------------ BETWEEN -----------------
    coluna1 BETWEEN 100 AND 500;

------------ IN -----------------
    coluna1 IN ('dado_01',
	'dado_02', 
	'dado_03');

------------ NOT IN -----------------
    coluna1 NOT IN ('dado_01',
	'dado_02', 
	'dado_03');

------------ NULL / NOT NULL -----------------
    coluna1 IS NULL;
    coluna1 IS NOT NULL;

------------  DATAS/ENTRE DATAS -----------------
    coluna1 BETWEEN '2024-01-01' AND '2024-12-31';
    YEAR(coluna1) = 2024;
    MONTH(coluna1) = 01;

************************************ FIM PESQUISAS WHERE ************************************

************************************ ORDENAR ************************************
-- ordenações (PADRÃO ASC/DESC, MÚLTIPLAS COLUNAS, COLUNAS CONSIDERADAS NÚMEROS, STRINGS TERÃO POSIÇÕES ESPECÍFICAS, TAMANHO DO TEXTO, STRINGS TERÃO POSIÇÕES ESPECÍFICA, TRECHOS TERÃO POSIÇÕES ESPECÍFICAS, NULLS NO FINAL, ORDENAR ALEATÓRIO)
SELECT
    coluna1, 
    coluna2,
    coluna3
FROM nome_do_banco
ORDER BY 
------------ PADRÃO ASC/DESC -----------------
coluna1;  -- DESC para decrescente, ASC é o padrão

------------ MÚLTIPLAS COLUNAS -----------------
    coluna1,
    coluna2;

------------ COLUNAS CONSIDERADAS NÚMEROS -----------------
	1, 3 -- 1 = primeira coluna do SELECT e 3 a terceira

------------ TAMANHO DO TEXTO -----------------
    LEN(coluna1) DESC;  -- Ordena pelo tamanho do texto

------------ STRINGS TERÃO POSIÇÕES ESPECÍFICAS -----------------
    CASE coluna1
        WHEN 'dado01' THEN 1 -- qualquer que seja 'dado01' será 1º na ordenação
        WHEN 'PENDENTE' THEN 2  -- qualquer que seja 'dado02' será 2º na ordenação
        WHEN 'INATIVO' THEN 3 -- qualquer que seja 'dado03' será 3º na ordenação
        ELSE 4 --demais 'dados' serão 4º na ordenação
    END;

------------ TRECHOS TERÃO POSIÇÕES ESPECÍFICAS -----------------
    CASE 
        WHEN coluna1 LIKE '%URGENTE%' THEN 1
        WHEN coluna1 LIKE '%IMPORTANTE%' THEN 2  
        ELSE 3
    END,

------------ NULLS NO FINAL -----------------
    coluna1 ASC NULLS LAST;   -- Nulos no final (SQL Server 2022+)

------------ ORDENAR ALEATÓRIO -----------------
ORDER BY NEWID();  -- Ordem aleatória (SQL Server)

************************************ FIM DE ORDENAR ************************************

************************************ AGRUPAR ************************************
___________________________________________________________________________________________________
| IMPORTANTE!!!                                                                                    |
| GROUP BY tem que ter função de agregação em SELECT (COUNT, SUM, AVG, MAX, MIN)                   |
| Toda coluna no SELECT que NÃO estiver dentro de COUNT/SUM/AVG/MAX/MIN precisa estar no GROUP BY! |
|__________________________________________________________________________________________________|
 -- Agrupamentos (Contagem, MÚLTIPLAS, HAVING)
SELECT
    coluna1,
    COUNT(*) AS total,      -- Obrigatório ter ao menos uma das agregação!
    SUM(coluna2) AS soma,
    AVG(coluna3) AS media,
    MAX(data) AS ultimo,
    MIN(data) AS primeiro
FROM nome_do_banco
GROUP BY coluna1; 

-- Contagem de linhas dados da coluna
SELECT 
    coluna1,
    COUNT(*) AS qtd
FROM nome_do_banco
GROUP BY coluna1;

-- 2. MÚLTIPLAS AGREGAÇÕES
SELECT 
    coluna1,
    coluna2,
    COUNT(*) AS total,
    AVG(nota_media) AS media,
    MAX(data_fundacao) AS maximo
FROM nome_do_banco
GROUP BY coluna1, coluna2;

-- 3. FILTRANDO GRUPOS (HAVING)
SELECT 
    categoria,
    COUNT(*) AS total,
    AVG(preco) AS preco
FROM produtos
GROUP BY categoria
HAVING COUNT(*) > 10  -- Só categorias com +10 produtos
    AND AVG(preco) > 50;  -- E preço médio > 50

************************************ FIM AGRUPAR ************************************

************************************ CRIAR TEMPORÁRIAS ************************************

------------ Criar Temporária ------------
DROP TABLE IF EXISTS #temp_01;
SELECT 
    coluna1, 
    coluna2
INTO #temp_01 
FROM nome_da_tabela;

------------ CRIAR ESTRUTURA SEM DADOS ------------
DROP TABLE IF EXISTS #temp_vazia;
SELECT TOP 0 * 
INTO #temp_vazia 
FROM nome_da_tabela;  -- Cria cópia da estrutura, sem dados

************************************ FIM CRIAR TEMPORÁRIAS ************************************

************************************ EDITAR TEMPORÁRIAS ************************************
-- O DROP TABLE deve vir ANTES do SELECT INTO, não no meio!

DROP TABLE IF EXISTS #temp_01;
SELECT
    coluna1,
    coluna2
INTO #temp_01 
FROM nome_da_tabela;
------------ RETIRAR NULL ------------
ISNULL(coluna1,'') AS novo_nome1,
ISNULL(coluna2, 0) AS com_zero, 

------------ INVERSO DO IS NULL ------------
NULLIF(coluna, 0) AS transforma_zero_em_null 

--------- EXCLUIR UMA LINHA INTEIRA ---------
DELETE FROM #temp_01 
WHERE coluna1 IS NULL;

--------- LIMPAR/EXCLUIR TABELA INTEIRA MANTENDO CABEÇALHO ---------
TRUNCATE TABLE #temp_01;

--------- CRIAR CÓPIA EXATA ---------
-- Estrutura + dados
SELECT * 
INTO #temp_copia 
FROM #temp_original;

-- Só estrutura (sem dados)
SELECT TOP 0 * 
INTO #temp_vazia 
FROM #temp_original;

------------ RENOMEAR COLUNAS ------------ 
    coluna1 AS novo_nome1,
    coluna2 AS novo_nome2

------------ RENOMEAR COLUNA EXISTENTE ------------
EXEC tempdb..sp_rename '#temp_01.coluna1', 'novo_nome', 'COLUMN'; --funciona fora da estrutura do SELECT

--------- ACRESCENTAR COLUNA VAZIA COM CABEÇALHO ---------
ALTER TABLE #temp_01 
ADD idade INT;

--------- EXCLUIR COLUNAS ---------
ALTER TABLE #temp_01 
DROP COLUMN coluna1, coluna2;

-- ANTES: #temp_01
╔════╦═══════╗
║ id ║ nome  ║
╠════╬═══════╣
║ 1  ║ Ana   ║
║ 2  ║ Bruno ║
╚════╩═══════╝

-- COMANDO (ERRADO - só ALTER TABLE)
ALTER TABLE #temp_01;  -- ❌ ERRO! Não faz nada

-- COMANDO (CORRETO)
ALTER TABLE #temp_01 ADD idade INT;  -- ✅ Funciona!

-- DEPOIS: #temp_01
╔════╦═══════╦═══════╗
║ id ║ nome  ║ idade ║
╠════╬═══════╬═══════╣
║ 1  ║ Ana   ║ NULL  ║
║ 2  ║ Bruno ║ NULL  ║
╚════╩═══════╩═══════╝

--------- INSERIR VALORES DO SCRIPT NAS COLUNAS ---------
INSERT INTO #temp_01 (coluna1, coluna2) 
VALUES ('valor1', 'valor2'); 

--------- INSERIR VALORES DO SCRIPT EM SEQUENCIA NAS COLUNAS ---------
INSERT INTO #temp_01 (coluna1, coluna2) 
VALUES 
    ('a', 1),
    ('b', 2),
    ('c', 3);

--------- INSERIR DADOS EM UMA COLUNA EM COMPARAÇÃO COM OUTRA COLUNA ---------
-- Atualização simples
UPDATE #temp_01 
SET coluna1 = 'novo_valor'
WHERE id = 1;

-- ANTES: #temp_01
╔════╦══════════╦═══════╗
║ id ║ coluna1  ║ preco ║
╠════╬══════════╬═══════╣
║ 1  ║ Ativo    ║ 100   ║
║ 2  ║ Inativo  ║ 200   ║
║ 3  ║ Ativo    ║ 150   ║
╚════╩══════════╩═══════╝

-- COMANDO
UPDATE #temp_01 
SET coluna1 = 'novo_valor'
WHERE id = 1;

-- DEPOIS: #temp_01 (só mudou o VALOR da linha 1)
╔════╦═════════════╦═══════╗
║ id ║ coluna1     ║ preco ║  ← CABEÇALHO IGUAL!
╠════╬═════════════╬═══════╣
║ 1  ║ novo_valor  ║ 100   ║  ← DADO ALTERADO
║ 2  ║ Inativo     ║ 200   ║
║ 3  ║ Ativo       ║ 150   ║
╚════╩═════════════╩═══════╝

--------- INSERIR COLUNAS DE UMA outra_tabela EM CIMA DAS COLUNAS DA TABELA #temp_01 ---------
INSERT INTO #temp_01 (coluna1, coluna2)
SELECT campo1, campo2 
FROM outra_tabela 

--------- INSERIR DADOS ESPECÍFICOS VINDOS DE UMA COLUNA DE outra_tabela EM COMPARAÇÃO COM AS COLUNAS DA TABELA #temp_01 ---------
UPDATE t
SET t.coluna1 = o.coluna_outra 
FROM #temp_01 t
INNER JOIN outra_tabela o ON t.id = o.id; -- dados da coluna id em ambas que forem iguais farão substituições em t.coluna1 com novos valores vindos da coluna o.coluna_outra.

-- ANTES: #temp_01 (t)
╔════╦══════════╦═══════╗
║ id ║ coluna1  ║ nome  ║
╠════╬══════════╬═══════╣
║ 1  �antigo     ║ Ana   ║
║ 2  ║antigo    ║ Bruno ║
║ 3  ║antigo    ║ Carla ║
╚════╩══════════╩═══════╝

-- ANTES: tabela_origem (o)
╔════╦═══════════════╗
║ id ║ valor_corrigido║
╠════╬═══════════════╣
║ 1  ║ corrigido_1   ║
║ 2  ║ corrigido_2   ║
╚════╩═══════════════╝

-- COMANDO (JOIN)
UPDATE t
SET t.coluna1 = o.valor_corrigido
FROM #temp_01 t
INNER JOIN tabela_origem o ON t.id = o.id;

-- DEPOIS: #temp_01 (só IDs 1 e 2 mudaram, 3 ficou igual!)
╔════╦═══════════════╦═══════╗
║ id ║ coluna1       ║ nome  ║
╠════╬═══════════════╬═══════╣
║ 1  ║ corrigido_1   ║ Ana   ║  ← Mudou (match)
║ 2  ║ corrigido_2   ║ Bruno ║  ← Mudou (match)
║ 3  ║ antigo        ║ Carla ║  ← Não mudou (sem match)
╚════╩═══════════════╩═══════╝
--------- INSERIR DADOS ESPECÍFICOS VINDOS DE várias COLUNA DE outra_tabela EM COMPARAÇÃO COM várias COLUNAS DA TABELA #temp_01 ---------
UPDATE t
SET 
    t.status = 'INATIVO',
    t.data_alteracao = GETDATE(),
    t.usuario = 'SISTEMA'
FROM #temp_01 t
INNER JOIN outra_tabela o ON t.id = o.id
WHERE o.data_cadastro < '2020-01-01';  
--------- CRIAR UMA NOVA TEMP #temp_uniao FORMADA POR COLUNAS DE #temp_a COM ACRÉSCIMO DE DADOS DAS COLUNAS DE #temp_b ABAIXO ---------
-- UNION (empilha)
SELECT * 
INTO #temp_uniao
FROM (
    SELECT 
        col1, 
        col2 
    FROM #temp_a
    UNION ALL  -- ALL mantém duplicatas, UNION remove
    SELECT 
         col1, 
         col2 
    FROM #temp_b
) AS uniao; --isso é apenas apelido da subconsulta


-- ANTES: #temp_a
╔══════╦══════╗
║ col1 ║ col2 ║
╠══════╬══════╣
║ A1   ║ X1   ║
║ A2   ║ X2   ║
╚══════╩══════╝

-- ANTES: #temp_b
╔══════╦══════╗
║ col1 ║ col2 ║
╠══════╬══════╣
║ B1   ║ Y1   ║
║ B2   ║ Y2   ║
╚══════╩══════╝

-- COMANDO (UNION ALL)
SELECT * INTO #temp_uniao
FROM (
    SELECT col1, col2 FROM #temp_a
    UNION ALL
    SELECT col1, col2 FROM #temp_b
) AS uniao;  -- ← Isso é só APELIDO da subconsulta!

-- DEPOIS: #temp_uniao
╔══════╦══════╗
║ col1 ║ col2 ║  ← 2 COLUNAS SEPARADAS!
╠══════╬══════╣
║ A1   ║ X1   ║
║ A2   ║ X2   ║
║ B1   ║ Y1   ║
║ B2   ║ Y2   ║
╚══════╩══════╝

--------- TRÊS COLUNAS DE TRÊS TABELAS DIFERENTES A, B, C em  #temp_join ---------
SELECT 
    a.*,
    b.coluna_extra,
    c.outra_coluna
INTO #temp_join
FROM #temp_a a
LEFT JOIN #temp_b b ON a.id = b.id
INNER JOIN #temp_c c ON a.id = c.id;

-- ANTES: #temp_a
╔════╦════════╗
║ id ║ nome   ║
╠════╬════════╣
║ 1  ║ Ana    ║
║ 2  ║ Bruno  ║
║ 3  ║ Carla  ║
╚════╩════════╝

-- ANTES: #temp_b
╔════╦════════════╗
║ id ║ coluna_extra║
╠════╬════════════╣
║ 1  ║ Extra1     ║
║ 3  ║ Extra3     ║
╚════╩════════════╝

-- ANTES: #temp_c
╔════╦══════════════╗
║ id ║ outra_coluna ║
╠════╬══════════════╣
║ 1  ║ Outra1       ║
║ 2  ║ Outra2       ║
║ 3  ║ Outra3       ║
╚════╩══════════════╝

-- COMANDO (LEFT JOIN c/ INNER JOIN)
SELECT 
    a.*,
    b.coluna_extra,
    c.outra_coluna
INTO #temp_join
FROM #temp_a a
LEFT JOIN #temp_b b ON a.id = b.id      -- Tudo de A + match B
INNER JOIN #temp_c c ON a.id = c.id;    -- Só IDs que existem em C

-- DEPOIS: #temp_join
╔════╦════════╦═════════════╦══════════════╗
║ id ║ nome   ║ coluna_extra║ outra_coluna ║
╠════╬════════╬═════════════╬══════════════╣
║ 1  ║ Ana    ║ Extra1      ║ Outra1       ║  ← Tem em B e C
║ 2  ║ Bruno  ║ NULL        ║ Outra2       ║  ← Não tem B, mas tem C
║ 3  ║ Carla  ║ Extra3      ║ Outra3       ║  ← Tem B e C
╚════╩════════╩═════════════╩══════════════╝
-- ⚠️ Bruno entrou pq tem INNER JOIN com C (id=2 existe em C)

--------- MERGE: SINCRONIZA TABELAS (UPDATE + INSERT AUTOMÁTICO) ---------
-- ATUALIZA registros existentes e INSERE os novos em UM COMANDO SÓMERGE INTO #temp_destino AS destino
USING #temp_origem AS origem
    ON destino.id = origem.id
WHEN MATCHED THEN
    UPDATE SET 
        destino.nome = origem.nome,
        destino.valor = origem.valor
WHEN NOT MATCHED THEN
    INSERT (id, nome, valor)
    VALUES (origem.id, origem.nome, origem.valor);

-- ANTES: #temp_destino
╔════╦════════╦═══════╗
║ id ║ nome   ║ valor ║
╠════╬════════╬═══════╣
║ 1  ║ Ana    ║ 100   ║
║ 2  ║ Bruno  ║ 200   ║
╚════╩════════╩═══════╝

-- ANTES: #temp_origem
╔════╦════════╦═══════╗
║ id ║ nome   ║ valor ║
╠════╬════════╬═══════╣
║ 2  ║ Bruno  ║ 250   ║  ← UPDATE (já existe)
║ 3  ║ Carla  ║ 300   ║  ← INSERT (novo)
╚════╩════════╩═══════╝

-- COMANDO MERGE
MERGE INTO #temp_destino AS destino
USING #temp_origem AS origem
    ON destino.id = origem.id
WHEN MATCHED THEN
    UPDATE SET 
        destino.nome = origem.nome,
        destino.valor = origem.valor
WHEN NOT MATCHED THEN
    INSERT (id, nome, valor)
    VALUES (origem.id, origem.nome, origem.valor);

-- DEPOIS: #temp_destino
╔════╦════════╦═══════╗
║ id ║ nome   ║ valor ║
╠════╬════════╬═══════╣
║ 1  ║ Ana    ║ 100   ║  ← Não foi alterado (não veio na origem)
║ 2  ║ Bruno  ║ 250   ║  ← UPDATE (valor mudou de 200 → 250)
║ 3  ║ Carla  ║ 300   ║  ← INSERT (novo registro)
╚════╩════════╩═══════╝

--------- ORDENAR DADOS DE UMA COLUNA NA TEMP, CRIANDO ÚLTIMA COLUNA COM ORDEM NUMÉRICA (TIPO ID)---------
-- Temp não tem ordem, mas você pode criar uma coluna de ordem
SELECT 
    *,
    ROW_NUMBER() OVER (ORDER BY data DESC) AS ordem_prioridade
INTO #temp_ordenada
FROM #temp_01;

-- ANTES: #temp_01 (sem ordem garantida)
╔════╦════════════╦═══════╗
║ id ║ data       ║ valor ║
╠════╬════════════╬═══════╣
║ 3  ║ 2024-01-01 ║ 300   ║
║ 1  ║ 2024-03-01 ║ 100   ║
║ 2  ║ 2024-02-01 ║ 200   ║
╚════╩════════════╩═══════╝

-- COMANDO
SELECT 
    *,
    ROW_NUMBER() OVER (ORDER BY data DESC) AS ordem_prioridade
INTO #temp_ordenada
FROM #temp_01;

-- DEPOIS: #temp_ordenada (ordem FÍSICA, não só exibição!)
╔════╦════════════╦═══════╦══════════════════╗
║ id ║ data       ║ valor ║ ordem_prioridade ║
╠════╬════════════╬═══════╬══════════════════╣
║ 1  ║ 2024-03-01 ║ 100   ║ 1               ║  ← Mais recente
║ 2  ║ 2024-02-01 ║ 200   ║ 2               ║
║ 3  ║ 2024-01-01 ║ 300   ║ 3               ║
╚════╩════════════╩═══════╩══════════════════╝
-- ⚠️ DIFERENÇA: ORDER BY normal só ORDENA EXIBIÇÃO
--    ROW_NUMBER CRIA COLUNA com números sequenciais

--------- CHECAR ERROS ESPECÍFICOS E CORRIGÍ-LOS ---------
ALTER TABLE #temp_01
ADD CONSTRAINT pk_temp PRIMARY KEY (id);  -- Chave primária

ALTER TABLE #temp_01
ADD CONSTRAINT ck_idade CHECK (idade >= 0);  -- Regra de validação

-- ANTES: #temp_01 (sem restrições)
╔════╦════════╦═══════╗
║ id ║ nome   ║ idade ║
╠════╬════════╬═══════╣
║ 1  ║ Ana    ║ 25    ║
║ 1  ║ Ana2   ║ 30    ║  ← Permite DUPLICADO!
║ 2  ║ Bruno  ║ -5    ║  ← Permite IDADE NEGATIVA!
╚════╩════════╩═══════╝

-- COMANDO 1: PK
ALTER TABLE #temp_01
ADD CONSTRAINT pk_temp PRIMARY KEY (id);  
-- ❌ ERRO! Tem id duplicado (1,1)

-- CORRIGINDO...
DELETE FROM #temp_01 WHERE nome = 'Ana2';  -- Remove duplicata

ALTER TABLE #temp_01
ADD CONSTRAINT pk_temp PRIMARY KEY (id);  
-- ✅ AGORA FUNCIONA!

-- COMANDO 2: CHECK
ALTER TABLE #temp_01
ADD CONSTRAINT ck_idade CHECK (idade >= 0);
-- ❌ ERRO! Tem idade negativa (-5)

-- CORRIGINDO...
UPDATE #temp_01 SET idade = 5 WHERE idade = -5;

ALTER TABLE #temp_01
ADD CONSTRAINT ck_idade CHECK (idade >= 0);
-- ✅ AGORA FUNCIONA!

-- DEPOIS: #temp_01
╔════╦════════╦═══════╗
║ id ║ nome   ║ idade ║
╠════╬════════╬═══════╣
║ 1  ║ Ana    ║ 25    ║  ← PK impede novo id=1
║ 2  ║ Bruno  ║ 5     ║  ← CHECK impede idade < 0
╚════╩════════╩═══════╝

************************************ FIM EDITAR TEMPORÁRIAS ************************************
